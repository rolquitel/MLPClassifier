# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLPClassifier
                                 A QGIS plugin
 Plugin Cuadros de lista
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-17
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Carlos Guzm√°n
        email                : cmejora63c@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_circles
from sklearn.neural_network import MLPRegressor

from osgeo import gdal

from os import X_OK
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsProject, Qgis

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .MLPClassifier_dialog import MLPClassifierDialog
import os.path


class MLPClassifier:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MLPClassifier_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MLP Classifier')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MLPClassifier', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/MLPClassifier/MLPClassifier.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MLP Classifier '),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MLP Classifier'),
                action)
            self.iface.removeToolBarIcon(action)

    def add_to_list(self):
        # Move items selected to list of trainning caps (RA)       
        itemsb=self.dlg.ltCapasRNA.selectedItems()
        for item in itemsb:
            row=self.dlg.ltCapasRNA.row(item )
            self.dlg.ltCapasRNA.takeItem(row)
            self.dlg.ltCapasRA.addItem(str(item.text() ))

    def rem_from_list(self):
        # Move items selected to list of caps RNA 
        itemsb=self.dlg.ltCapasRA.selectedItems()
        for item in itemsb:
            row=self.dlg.ltCapasRA.row(item )
            self.dlg.ltCapasRA.takeItem(row)
            self.dlg.ltCapasRNA.addItem(str(item.text()))



    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = MLPClassifierDialog()
            self.dlg.btAgregar.clicked.connect(self.add_to_list)
            self.dlg.btQuitar.clicked.connect(self.rem_from_list)
            self.dlg.btEntrenar.clicked.connect(self.run_training)
 
        self.loadLayers()
        
        # Clear the contents of the listWidgets from previous runs
        
        self.dlg.ltCapasRNA.clear()
        self.dlg.ltCapasRA.clear()
        
        # Populate the listWidget with  names of all tne loaded layers
        #self.dlg.ltCapasRNA.addItems([layer.name() for layer in layers])
        layers = QgsProject.instance().mapLayers().values()
        for l in layers:
            if l.type() == 0:
                self.dlg.cbZonasEntrenamiento.addItem(l.name())
            else:
                self.dlg.ltCapasRNA.addItem(l.name())       
        #self.dlg.listWidget.setSelectionMode(2)
            
        
        # show the dialog
        self.dlg.show()
       
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #pass
            #select the first item of the listWiddget RA
            item1LsRA=self.dlg.ltCapasRA.item(0)
            if item1LsRA != None :
                # Recover layer from layer dictionary
                layer = self.lyDic[str(item1LsRA.text())]
                # Copy layer and create instance
                layer_copyName = layer.name() + "_copy"
                layer_copy = layer.clone()
                layer_copy.setName(layer_copyName)
                QgsProject.instance().addMapLayer(layer_copy)
                
    def loadLayers(self):
        # Fetch the currently loaded layers
        # layers = QgsProject.instance().layerTreeRoot().children()
        # layers=self.iface.mapCanvas().layers()
        layers = QgsProject.instance().mapLayers().values()
        self.lyDic = {}
        for l in layers:
            self.lyDic[l.name()] = l

    def training(self, inputs, outputs, 
        hidden_layer_sizes=[2,16,8,1], 
        solver='sgd', 
        max_iter=100, 
        learning_rate=0.002, 
        verbose=False,
        n_iter_no_change=10,
        batch_size=64):

        # SciKit Learn
        model = MLPRegressor(
            solver=solver, 
            max_iter=max_iter,
            learning_rate_init=learning_rate, 
            hidden_layer_sizes=tuple(hidden_layer_sizes[1:]), 
            verbose=verbose, 
            n_iter_no_change=n_iter_no_change, 
            batch_size = batch_size
            )

        model.fit(inputs, outputs)

        return model

    def run_training(self):
        import random
        # Get raster bands
        bands = []
        for i in range(self.dlg.ltCapasRA.count()):
            bands.append(self.dlg.ltCapasRA.item(i).text())

        print('Bandas', bands)

        # Get training layer
        trainLayer = self.dlg.cbZonasEntrenamiento.currentText()
        print('Capa de entrenamiento', trainLayer)

        # Preprocessing
        print('Preprocesamiento ...')
        self.nClasses = self.preprocessing(bands, trainLayer)
        print('Ok.')

        # Get training data
        trainInputs = []
        trainOutputs = []
        for clase in range(1, self.nClasses+1):
            print('Extrayendo datos de la clase', clase, end=' ')
            trainRasterLayers = []
            for band in bands:
                trainRasterLayers.append(band + '_class_' + str(clase))

            ti, to = self.extractTrainData(clase, trainRasterLayers, stride=10)
            trainInputs = trainInputs + ti
            trainOutputs = trainOutputs + to
            print('Ok.')

        train = list(zip(trainInputs, trainOutputs))
        random.shuffle(train)
        trainInputs, trainOutputs = zip(*train)

        print(len(trainInputs))

        sep = round(len(trainInputs) * 0.8)
        testInputs = trainInputs[sep:]
        testOutputs = trainOutputs[sep:]

        trainInputs = trainInputs[0:sep]
        trainOutputs = trainOutputs[0:sep]
        
        print('Entrenando ... ', end='')
        model = self.training(trainInputs, trainOutputs, verbose=True, n_iter_no_change=100, max_iter=500)
        print('Ok')

        print('Prediciendo ... ', end='')
        predictedOutputs = model.predict(testInputs)
        print('Ok')
        
        mse = 0
        for i in range(len(testOutputs)):
            mse += (testOutputs[i] - predictedOutputs[i]) ** 2
        mse /= len(testOutputs)
        print('MSE:', mse)

        print('Guardando CSV ... ', end='')
        outs = zip(testOutputs, predictedOutputs)
        self.saveToCSV('outs', outs)
        print('Ok.')

    
    def saveToCSV(self, filename, data):
        import csv

        with open(os.path.join(self.workDir,filename +'.csv'), mode='w') as csv_file:
            csv_writer = csv.writer(csv_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            csv_writer.writerows(data)


    def preprocessing(self, bands, trainLyrName, group='MLPClassifier'):
        from pathlib import Path
        import qgis

        # inicializar directorio de trabajo
        prjPath = QgsProject.instance().homePath()
        self.workDir = os.path.join(prjPath, group)
        Path(self.workDir).mkdir(parents=True, exist_ok=True)

        # verificar que la capa de entrenamiento tenga el atributo de clase
        trainLayer = self.lyDic[trainLyrName]
        fieldNames = trainLayer.fields().names()
        classFldIdx = -1
        for idx, name in enumerate(fieldNames):
            if name == 'clase':
                classFldIdx = idx

        classes = 0
        if classFldIdx < 0:
            print('No hay atributo de clase')
        else:
            for feat in trainLayer.getFeatures():
                featClass = feat.attributes()[classFldIdx]
                if featClass > classes:
                    classes = featClass

            root = QgsProject.instance().layerTreeRoot()
            MLPCGroup = root.findGroup(group)
            if MLPCGroup is None:
                MLPCGroup = root.addGroup(group)
                MLPCGroup.addLayer(trainLayer)
            
            for clase in range(1,classes+1):
                print('Procesando clase', clase, ' ...', end='') 
                bandGroup = MLPCGroup.addGroup('Clase ' + str(clase))
                for band in bands:
                    print('banda', band, end=', ')
                    in_raster = self.lyDic[band].source()
                    rasterName = band + '_class_'+ str(clase)

                    # Ya se ha creado el clip?
                    if rasterName not in self.lyDic:
                        out_raster = os.path.join(self.workDir , rasterName + '.tif')
                        options = gdal.WarpOptions(cutlineDSName=trainLayer.source(), cutlineWhere='clase='+str(clase))
                        gdal.Warp(out_raster, in_raster, options=options)
                        rlayer = qgis.core.QgsRasterLayer(out_raster, rasterName)
                        QgsProject.instance().addMapLayer(rlayer, False)
                        bandGroup.addLayer(rlayer)
                    else:
                        print('ya existe en el proyecto!', end=' ')
                print('Ok.')

            self.loadLayers()

        return classes
        
    def classVector(self, clase):
        cv = [0] * self.nClasses
        cv[clase] = 1
        return cv

    def extractTrainData(self, clase, rasterLayers, stride=2):
        bands = []
        maxBandVal = []
        nBands = len(rasterLayers)
        for rasterLayer in rasterLayers:
            layer = self.lyDic[rasterLayer]
            # rasterData = gdal.Open(layer.dataProvider().dataSourceUri())
            rasterData = gdal.Open(layer.source())
            rasterArray = rasterData.GetRasterBand(1).ReadAsArray()
            bands.append(rasterArray)
            maxBandVal.append(np.amax(rasterArray))

        print(bands[0].shape)
        sx, sy = bands[0].shape
        trainInputs = []
        trainOutputs = []

        for y in range(0,sy, stride):
            if y % round(sy / 10) < stride:
                print(round(100 * y / sy),'%, ', sep='', end=' ')
                
            for x in range(0, sx, stride):
                pxVal = 0
                pxVec = [x/sx, y/sy]
                for band in range(nBands):
                    pxVal += bands[band][x,y]
                    pxVec.append(bands[band][x,y] / maxBandVal[band])
                    
                if pxVal > 0:
                    trainInputs.append(pxVec)
                    trainOutputs.append(clase / self.nClasses)

        print(len(trainInputs))

        return trainInputs, trainOutputs
