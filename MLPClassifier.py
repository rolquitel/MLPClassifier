# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MLPClassifier
                                 A QGIS plugin
 Plugin Cuadros de lista
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-17
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Carlos Guzmán
        email                : cmejora63c@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_circles
from sklearn.neural_network import MLPRegressor

from osgeo import gdal

from os import X_OK
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsProject, Qgis

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .MLPClassifier_dialog import MLPClassifierDialog
import os.path
from pathlib import Path
from joblib import dump, load
import random
import qgis

from .util import writeArrayToTIFF, echo

class MLPClassifier:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MLPClassifier_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MLP Classifier')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MLPClassifier', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/MLPClassifier/MLPClassifier.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MLP Classifier '),
            callback=self.run,
            parent=self.iface.mainWindow())

        # inicializar directorio de trabajo
        prjPath = QgsProject.instance().homePath()
        self.workDir = os.path.join(prjPath, 'MLPClassifier')
        Path(self.workDir).mkdir(parents=True, exist_ok=True)

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MLP Classifier'),
                action)
            self.iface.removeToolBarIcon(action)

    def add_to_list(self):
        # Move items selected to list of trainning caps (RA)       
        itemsb=self.dlg.ltCapasRNA.selectedItems()
        for item in itemsb:
            row=self.dlg.ltCapasRNA.row(item )
            self.dlg.ltCapasRNA.takeItem(row)
            self.dlg.ltCapasRA.addItem(str(item.text() ))

    def rem_from_list(self):
        # Move items selected to list of caps RNA 
        itemsb=self.dlg.ltCapasRA.selectedItems()
        for item in itemsb:
            row=self.dlg.ltCapasRA.row(item )
            self.dlg.ltCapasRA.takeItem(row)
            self.dlg.ltCapasRNA.addItem(str(item.text()))



    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            echo("Primera ejecución.",verbose=True)
            self.first_start = False
            self.dlg = MLPClassifierDialog()
            self.dlg.btAgregar.clicked.connect(self.add_to_list)
            self.dlg.btQuitar.clicked.connect(self.rem_from_list)
            self.dlg.btEntrenar.clicked.connect(self.run_training)
            self.dlg.btClasificar.clicked.connect(self.run_classify)
 
            echo('Cargar capas', verbose=True)
            self.loadLayers()            
            self.dlg.ltCapasRNA.clear()
            self.dlg.ltCapasRA.clear()
            layers = QgsProject.instance().mapLayers().values()
            for l in layers:
                if l.type() == 0:
                    self.dlg.cbZonasEntrenamiento.addItem(l.name())
                else:
                    self.dlg.ltCapasRNA.addItem(l.name())       
            #self.dlg.listWidget.setSelectionMode(2)

            echo('Verificar si ya se ha entrenado')
            self.model = None
            self.dlg.btClasificar.setDisabled(True)
            model = Path(os.path.join(self.workDir, 'model.joblib'))
            if model.is_file():
                self.model = load(os.path.join(self.workDir, 'model.joblib'))
                self.dlg.btClasificar.setDisabled(False)

        # show the dialog
        self.dlg.show()
       
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        # if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            #pass
            #select the first item of the listWiddget RA
            # item1LsRA=self.dlg.ltCapasRA.item(0)
            # if item1LsRA != None :
            #     # Recover layer from layer dictionary
            #     layer = self.lyDic[str(item1LsRA.text())]
            #     # Copy layer and create instance
            #     layer_copyName = layer.name() + "_copy"
            #     layer_copy = layer.clone()
            #     layer_copy.setName(layer_copyName)
            #     QgsProject.instance().addMapLayer(layer_copy)
                
    def loadLayers(self):
        # Fetch the currently loaded layers
        # layers = QgsProject.instance().layerTreeRoot().children()
        # layers=self.iface.mapCanvas().layers()
        layers = QgsProject.instance().mapLayers().values()
        self.lyDic = {}
        for l in layers:
            self.lyDic[l.name()] = l

    def training(self, inputs, outputs, 
        hidden_layer_sizes=[2,16,8,1], 
        solver='sgd', 
        max_iter=100, 
        learning_rate=0.002, 
        verbose=False,
        n_iter_no_change=10,
        batch_size=64):

        # SciKit Learn
        model = MLPRegressor(
            solver=solver, 
            max_iter=max_iter,
            learning_rate_init=learning_rate, 
            hidden_layer_sizes=tuple(hidden_layer_sizes[1:]), 
            verbose=verbose, 
            n_iter_no_change=n_iter_no_change, 
            batch_size = batch_size
            )

        model.fit(inputs, outputs)

        return model

    def run_classify(self):
        bands = []
        for i in range(self.dlg.ltCapasRA.count()):
            bands.append(self.dlg.ltCapasRA.item(i).text())

        self.classify(bands, self.nClasses)

        rlayer = qgis.core.QgsRasterLayer(os.path.join(self.workDir,'result.tif'), 'result')
        QgsProject.instance().addMapLayer(rlayer)

    def run_training(self):
        # Get raster bands
        bands = []
        for i in range(self.dlg.ltCapasRA.count()):
            bands.append(self.dlg.ltCapasRA.item(i).text())

        print('Bandas', bands)

        # Get training layer
        trainLayer = self.dlg.cbZonasEntrenamiento.currentText()
        print('Capa de entrenamiento', trainLayer)

        # Preprocessing
        print('Preprocesamiento ...')
        self.nClasses = self.preprocessing(bands, trainLayer)
        print('Ok.')

        # Get training data
        trainInputs = []
        trainOutputs = []
        for clase in range(1, self.nClasses+1):
            print('Extrayendo datos de la clase', clase, end=' ')
            trainRasterLayers = []
            for band in bands:
                trainRasterLayers.append(band + '_class_' + str(clase))

            ti, to = self.extractTrainData(clase, trainRasterLayers, stride=10)
            trainInputs = trainInputs + ti
            trainOutputs = trainOutputs + to
            print('Ok.')

        train = list(zip(trainInputs, trainOutputs))
        random.shuffle(train)
        trainInputs, trainOutputs = zip(*train)

        print(len(trainInputs))

        sep = round(len(trainInputs) * 0.8)
        testInputs = trainInputs[sep:]
        testOutputs = trainOutputs[sep:]

        trainInputs = trainInputs[0:sep]
        trainOutputs = trainOutputs[0:sep]
        
        print('Entrenando ... ', end='')
        self.model = self.training(trainInputs, trainOutputs, verbose=True, n_iter_no_change=100, max_iter=500)
        print('Ok')

        print('Prediciendo ... ', end='')
        predictedOutputs = self.model.predict(testInputs)
        print('Ok')
        
        mse = 0
        for i in range(len(testOutputs)):
            mse += (testOutputs[i] - predictedOutputs[i]) ** 2
        mse /= len(testOutputs)
        print('MSE:', mse)

        print('Guardando CSV ... ', end='')
        outs = zip(testOutputs, predictedOutputs)
        self.saveToCSV('outs', outs)
        print('Ok.')

        echo('Dumping model ... ', end='', verbose=True)
        dump(self.model, os.path.join(self.workDir, 'model.joblib')) 
        echo('Ok', verbose=True)

        self.dlg.btClasificar.setDisabled(False)

    
    def saveToCSV(self, filename, data):
        import csv

        with open(os.path.join(self.workDir,filename +'.csv'), mode='w') as csv_file:
            csv_writer = csv.writer(csv_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            csv_writer.writerows(data)


    def preprocessing(self, bands, trainLyrName, group='MLPClassifier'):
        # verificar que la capa de entrenamiento tenga el atributo de clase
        trainLayer = self.lyDic[trainLyrName]
        fieldNames = trainLayer.fields().names()
        classFldIdx = -1
        for idx, name in enumerate(fieldNames):
            if name == 'clase':
                classFldIdx = idx

        classes = 0
        if classFldIdx < 0:
            print('No hay atributo de clase')
        else:
            for feat in trainLayer.getFeatures():
                featClass = feat.attributes()[classFldIdx]
                if featClass > classes:
                    classes = featClass

            root = QgsProject.instance().layerTreeRoot()
            MLPCGroup = root.findGroup(group)
            groupExists = True
            if MLPCGroup is None:
                MLPCGroup = root.addGroup(group)
                MLPCGroup.addLayer(trainLayer)
                groupExists = False
            
            for clase in range(1,classes+1):
                print('Procesando clase', clase, ' ...', end='') 

                bandGroup = MLPCGroup.addGroup('Clase ' + str(clase))
                for band in bands:
                    print('banda', band, end=', ')
                    in_raster = self.lyDic[band].source()
                    rasterName = band + '_class_'+ str(clase)

                    # Ya se ha creado el clip?
                    if rasterName not in self.lyDic:
                        out_raster = os.path.join(self.workDir , rasterName + '.tif')
                        options = gdal.WarpOptions(cutlineDSName=trainLayer.source(), cutlineWhere='clase='+str(clase))
                        gdal.Warp(out_raster, in_raster, options=options)
                        rlayer = qgis.core.QgsRasterLayer(out_raster, rasterName)
                        QgsProject.instance().addMapLayer(rlayer, False)
                        bandGroup.addLayer(rlayer)
                    else:
                        print('ya existe en el proyecto!', end=' ')
                print('Ok.')

            self.loadLayers()

        return classes
        
    def classVector(self, clase):
        cv = [0] * self.nClasses
        cv[clase] = 1
        return cv

    def classify(self, rasterLayers, nClasses):
        bands = []                                                  # lista con las bandas para la clasificación
        sx = 1                                                      # tamaño en x
        sy = 1                                                      # tamaño en y

        for rasterLayer in rasterLayers:                            # para cada capa raster en la clasificacion
            layer = self.lyDic[rasterLayer]                         # buscar la capa en el diccionario de capas
            print('Procesando raster', rasterLayer, '...')
            rasterData = gdal.Open(layer.source())                  # abrir el archivo original
            rasterArray = rasterData.GetRasterBand(1).ReadAsArray() # leemos los datos como un arreglo
            transform = rasterData.GetGeoTransform()                # obtener la transformación geográfica
            projection = rasterData.GetProjection()                 # obtener la proyección geográfica

            maxBandVal = np.amax(rasterArray)                       # calculamos el valor máximo de la banda para normalizar
            sx, sy = rasterArray.shape                              # guardamos el tamaño original del arreglo
            print(rasterArray.shape)
            rasterArray = rasterArray.reshape(-1)                   # convertimos en un arreglo de 1 dimensión
            bands.append([(val / maxBandVal) for val in rasterArray])   # agregamos la el arreglo normalizado a la lista de bandas

        print('Calculando Xs y Ys ...')
        ys = np.array([[y/sy]*sx for y in range(sy)])               # para los valores de las coordenadas verticales
        xs = np.transpose(np.array([[x/sx]*sy for x in range(sx)])) # para los valores de las coordenadas horizontales
        ys = ys.reshape(-1)                                         # convertirlos a un arreglo unidimensional
        xs = xs.reshape(-1)

        bands.insert(0, ys)                                         # agregarlos al inicio de la lista de bandas para preservar
        bands.insert(0, xs)                                         # el orden para la clasificación (x, y, b0, b1, b2, ...)

        batchCount = sy                                             # número de lotes
        batchSize = sx                                              # calcular el tamaño de cada lote
        print('Iniciando clasificación\nTamaño del lote:', batchSize)
        outBand = []                                                # arreglo de salida
        for b in range(batchCount):                                 # para cada lote 
            if b % round(batchCount / 100) ==0:
                print('\r',round(100*b/batchCount, 2), '%', end='')    
                # print('\r', end='') 
            batch = list(zip(*[band[(b*batchSize):((b+1)*batchSize)] for band in bands]))   # crear el lote   
            outBand.append([round(x*nClasses) for x in self.model.predict(batch)]) # clasificar, desnormalizar y agregar a la salida
        print('Ok')

        outBand = np.transpose(np.array(outBand))                   # convertir y transponer con numpy
        print(outBand.shape)

        # Escribir raster
        writeArrayToTIFF(os.path.join(self.workDir,'result.tif'), outBand, transform, projection, verbose=True)


    def extractTrainData(self, clase, rasterLayers, stride=2):
        bands = []
        maxBandVal = []
        nBands = len(rasterLayers)
        for rasterLayer in rasterLayers:
            layer = self.lyDic[rasterLayer]
            # rasterData = gdal.Open(layer.dataProvider().dataSourceUri())
            rasterData = gdal.Open(layer.source())
            rasterArray = rasterData.GetRasterBand(1).ReadAsArray()
            bands.append(rasterArray)
            maxBandVal.append(np.amax(rasterArray))

        print(bands[0].shape)
        sx, sy = bands[0].shape
        trainInputs = []
        trainOutputs = []

        for y in range(0,sy, stride):
            if y % round(sy / 10) < stride:
                print(round(100 * y / sy),'%, ', sep='', end=' ')
                
            for x in range(0, sx, stride):
                pxVal = 0
                pxVec = [x/sx, y/sy]
                for band in range(nBands):
                    pxVal += bands[band][x,y]
                    pxVec.append(bands[band][x,y] / maxBandVal[band])
                    
                if pxVal > 0:
                    trainInputs.append(pxVec)
                    trainOutputs.append(clase / self.nClasses)

        print(len(trainInputs))

        return trainInputs, trainOutputs
